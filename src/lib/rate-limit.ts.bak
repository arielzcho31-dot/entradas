// Rate limiting utility para TicketWise
// Implementación simple con memoria (para producción considera Redis)

interface RateLimitEntry {
  count: number;
  resetTime: number;
}

const rateLimitStore = new Map<string, RateLimitEntry>();

// Limpiar entradas expiradas cada 5 minutos
setInterval(() => {
  const now = Date.now();
  for (const [key, entry] of rateLimitStore.entries()) {
    if (entry.resetTime < now) {
      rateLimitStore.delete(key);
    }
  }
}, 5 * 60 * 1000);

export async function rateLimit(
  identifier: string,
  route: string,
  limit: number,
  windowInSeconds: number
): Promise<{
  success: boolean;
  limit: number;
  remaining: number;
  reset: number;
}> {
  const key = `${identifier}:${route}`;
  const now = Date.now();
  const windowMs = windowInSeconds * 1000;
  
  const entry = rateLimitStore.get(key);
  
  if (!entry || entry.resetTime <= now) {
    // Primera request o ventana expirada
    rateLimitStore.set(key, {
      count: 1,
      resetTime: now + windowMs,
    });
    
    return {
      success: true,
      limit,
      remaining: limit - 1,
      reset: now + windowMs,
    };
  }
  
  if (entry.count >= limit) {
    // Límite excedido
    return {
      success: false,
      limit,
      remaining: 0,
      reset: entry.resetTime,
    };
  }
  
  // Incrementar contador
  entry.count++;
  rateLimitStore.set(key, entry);
  
  return {
    success: true,
    limit,
    remaining: limit - entry.count,
    reset: entry.resetTime,
  };
}

// Rate limiting específico para diferentes tipos de operaciones
export const rateLimiters = {
  // Autenticación: más restrictivo
  auth: (ip: string) => rateLimit(ip, 'auth', 5, 60),
  
  // Uploads: muy restrictivo
  upload: (ip: string) => rateLimit(ip, 'upload', 3, 60),
  
  // API general: moderado
  api: (ip: string) => rateLimit(ip, 'api', 20, 60),
  
  // Búsquedas: más permisivo
  search: (ip: string) => rateLimit(ip, 'search', 50, 60),
  
  // Dashboard: normal
  dashboard: (ip: string) => rateLimit(ip, 'dashboard', 30, 60),
};

// Rate limiting por usuario autenticado (más permisivo)
export async function userRateLimit(
  userId: string,
  operation: string,
  limit: number,
  windowInSeconds: number
): Promise<{
  success: boolean;
  limit: number;
  remaining: number;
  reset: number;
}> {
  return rateLimit(`user:${userId}`, operation, limit, windowInSeconds);
}

// Configuraciones predefinidas por tipo de operación
export const operationLimits = {
  // Operaciones críticas
  purchase: { limit: 3, window: 300 }, // 3 compras por 5 minutos
  ticketGeneration: { limit: 10, window: 60 }, // 10 tickets por minuto
  
  // Operaciones normales
  orderCreation: { limit: 5, window: 60 }, // 5 órdenes por minuto
  profileUpdate: { limit: 3, window: 300 }, // 3 actualizaciones por 5 minutos
  
  // Operaciones de consulta
  orderList: { limit: 30, window: 60 }, // 30 consultas por minuto
  ticketValidation: { limit: 100, window: 60 }, // 100 validaciones por minuto (escáner)
};

// Helper para aplicar rate limiting en API routes
export function withRateLimit(
  operation: keyof typeof operationLimits,
  handler: Function
) {
  return async (req: Request, context: any) => {
    const ip = req.headers.get('x-forwarded-for') || 'unknown';
    const config = operationLimits[operation];
    
    const result = await rateLimit(ip, operation, config.limit, config.window);
    
    if (!result.success) {
      return new Response(
        JSON.stringify({
          error: 'Rate limit exceeded',
          message: `Too many ${operation} requests. Please try again later.`,
          retryAfter: Math.ceil((result.reset - Date.now()) / 1000),
        }),
        {
          status: 429,
          headers: {
            'Content-Type': 'application/json',
            'X-RateLimit-Limit': result.limit.toString(),
            'X-RateLimit-Remaining': result.remaining.toString(),
            'X-RateLimit-Reset': result.reset.toString(),
            'Retry-After': Math.ceil((result.reset - Date.now()) / 1000).toString(),
          },
        }
      );
    }
    
    // Continuar con el handler original
    const response = await handler(req, context);
    
    // Agregar headers de rate limiting a la respuesta
    if (response instanceof Response) {
      response.headers.set('X-RateLimit-Limit', result.limit.toString());
      response.headers.set('X-RateLimit-Remaining', result.remaining.toString());
      response.headers.set('X-RateLimit-Reset', result.reset.toString());
    }
    
    return response;
  };
}